/**
 * Hydraulic Damper Integration with Fuzzy Control System
 * 
 * This module integrates the hydraulic electromagnetic regenerative damper
 * with the existing fuzzy control system for comprehensive energy management.
 */

import { 
  HydraulicElectromagneticRegenerativeDamper,
  DamperInputs,
  DamperOutputs,
  DamperConfiguration,
  DamperConstraints
} from './HydraulicElectromagneticRegenerativeDamper';

import {
  FuzzyControlIntegration,
  SystemInputs,
  SystemOutputs
} from './FuzzyControlIntegration';

import { VehicleParameters } from './RegenerativeBrakingTorqueModel';

export interface IntegratedSystemInputs extends SystemInputs {
  /** Suspension inputs for each wheel */
  suspensionInputs: {
    frontLeft: DamperInputs;
    frontRight: DamperInputs;
    rearLeft: DamperInputs;
    rearRight: DamperInputs;
  };
}

export interface IntegratedSystemOutputs extends SystemOutputs {
  /** Damper outputs for each wheel */
  damperOutputs: {
    frontLeft: DamperOutputs;
    frontRight: DamperOutputs;
    rearLeft: DamperOutputs;
    rearRight: DamperOutputs;
  };
  /** Total power generated by all dampers (W) */
  totalDamperPower: number;
  /** Total energy harvested by dampers (J) */
  totalDamperEnergy: number;
  /** Combined energy efficiency including dampers */
  combinedEnergyEfficiency: number;
  /** System-wide energy balance */
  energyBalance: {
    regenerativeBrakingPower: number;
    damperPower: number;
    totalGeneratedPower: number;
    powerConsumption: number;
    netEnergyFlow: number;
  };
}

export interface HydraulicDamperSystemConfig {
  /** Configuration for each damper */
  damperConfigs: {
    front: DamperConfiguration;
    rear: DamperConfiguration;
  };
  /** Constraints for each damper */
  damperConstraints: {
    front: DamperConstraints;
    rear: DamperConstraints;
  };
  /** Energy management settings */
  energyManagement: {
    prioritizeBrakingOverDamping: boolean;
    maxCombinedPower: number;
    batteryChargingThreshold: number;
    thermalManagementEnabled: boolean;
  };
}

export class HydraulicDamperIntegration {
  private fuzzyControlSystem: FuzzyControlIntegration;
  private dampers: {
    frontLeft: HydraulicElectromagneticRegenerativeDamper;
    frontRight: HydraulicElectromagneticRegenerativeDamper;
    rearLeft: HydraulicElectromagneticRegenerativeDamper;
    rearRight: HydraulicElectromagneticRegenerativeDamper;
  };
  private config: HydraulicDamperSystemConfig;
  private totalSystemEnergy: number = 0;
  private operationTime: number = 0;

  constructor(
    vehicleParams: VehicleParameters,
    systemConfig?: Partial<HydraulicDamperSystemConfig>
  ) {
    // Initialize fuzzy control system
    this.fuzzyControlSystem = new FuzzyControlIntegration(vehicleParams);

    // Initialize dampers for each wheel
    this.dampers = {
      frontLeft: new HydraulicElectromagneticRegenerativeDamper(
        systemConfig?.damperConfigs?.front,
        systemConfig?.damperConstraints?.front
      ),
      frontRight: new HydraulicElectromagneticRegenerativeDamper(
        systemConfig?.damperConfigs?.front,
        systemConfig?.damperConstraints?.front
      ),
      rearLeft: new HydraulicElectromagneticRegenerativeDamper(
        systemConfig?.damperConfigs?.rear,
        systemConfig?.damperConstraints?.rear
      ),
      rearRight: new HydraulicElectromagneticRegenerativeDamper(
        systemConfig?.damperConfigs?.rear,
        systemConfig?.damperConstraints?.rear
      )
    };

    // Set default configuration
    this.config = {
      damperConfigs: {
        front: {
          maxDampingForce: 8000,
          maxElectromagneticForce: 2000,
          coilResistance: 0.5,
          magneticFluxDensity: 1.2,
          coilLength: 0.15,
          cylinderDiameter: 0.05,
          maxOperatingTemperature: 120,
          conversionEfficiency: 0.85
        },
        rear: {
          maxDampingForce: 7000,
          maxElectromagneticForce: 1800,
          coilResistance: 0.5,
          magneticFluxDensity: 1.2,
          coilLength: 0.15,
          cylinderDiameter: 0.05,
          maxOperatingTemperature: 120,
          conversionEfficiency: 0.85
        }
      },
      damperConstraints: {
        front: {
          maxCompressionVelocity: 2.0,
          maxExtensionVelocity: 2.0,
          maxDisplacement: 0.15,
          minDisplacement: -0.15,
          maxPowerOutput: 1500,
          temperatureDeratingThreshold: 100
        },
        rear: {
          maxCompressionVelocity: 2.0,
          maxExtensionVelocity: 2.0,
          maxDisplacement: 0.15,
          minDisplacement: -0.15,
          maxPowerOutput: 1200,
          temperatureDeratingThreshold: 100
        }
      },
      energyManagement: {
        prioritizeBrakingOverDamping: true,
        maxCombinedPower: 8000,
        batteryChargingThreshold: 0.95,
        thermalManagementEnabled: true
      },
      ...systemConfig
    };
  }

  /**
   * Calculate integrated system performance including both braking and damping
   */
  public calculateIntegratedPerformance(inputs: IntegratedSystemInputs): IntegratedSystemOutputs {
    this.validateIntegratedInputs(inputs);
    this.operationTime += 0.01; // Assume 10ms calculation interval

    // Calculate fuzzy control system outputs
    const fuzzyOutputs = this.fuzzyControlSystem.calculateOptimalControl(inputs);

    // Calculate damper outputs for each wheel
    const damperOutputs = {
      frontLeft: this.dampers.frontLeft.calculateDamperPerformance(inputs.suspensionInputs.frontLeft),
      frontRight: this.dampers.frontRight.calculateDamperPerformance(inputs.suspensionInputs.frontRight),
      rearLeft: this.dampers.rearLeft.calculateDamperPerformance(inputs.suspensionInputs.rearLeft),
      rearRight: this.dampers.rearRight.calculateDamperPerformance(inputs.suspensionInputs.rearRight)
    };

    // Calculate total damper power and energy
    const totalDamperPower = this.calculateTotalDamperPower(damperOutputs);
    const totalDamperEnergy = this.calculateTotalDamperEnergy(damperOutputs);

    // Calculate combined energy efficiency
    const combinedEnergyEfficiency = this.calculateCombinedEfficiency(
      fuzzyOutputs,
      damperOutputs,
      totalDamperPower
    );

    // Calculate energy balance
    const energyBalance = this.calculateEnergyBalance(
      fuzzyOutputs,
      totalDamperPower,
      inputs
    );

    // Apply energy management strategies
    const managedOutputs = this.applyEnergyManagement(
      fuzzyOutputs,
      damperOutputs,
      totalDamperPower,
      inputs
    );

    // Update total system energy
    this.totalSystemEnergy += totalDamperEnergy + (fuzzyOutputs.regeneratedPower * 0.01);

    return {
      ...managedOutputs.fuzzyOutputs,
      damperOutputs: managedOutputs.damperOutputs,
      totalDamperPower: managedOutputs.totalDamperPower,
      totalDamperEnergy,
      combinedEnergyEfficiency,
      energyBalance
    };
  }

  /**
   * Calculate total power generated by all dampers
   */
  private calculateTotalDamperPower(damperOutputs: {
    frontLeft: DamperOutputs;
    frontRight: DamperOutputs;
    rearLeft: DamperOutputs;
    rearRight: DamperOutputs;
  }): number {
    return damperOutputs.frontLeft.generatedPower +
           damperOutputs.frontRight.generatedPower +
           damperOutputs.rearLeft.generatedPower +
           damperOutputs.rearRight.generatedPower;
  }

  /**
   * Calculate total energy harvested by all dampers
   */
  private calculateTotalDamperEnergy(damperOutputs: {
    frontLeft: DamperOutputs;
    frontRight: DamperOutputs;
    rearLeft: DamperOutputs;
    rearRight: DamperOutputs;
  }): number {
    return damperOutputs.frontLeft.harvestedEnergy +
           damperOutputs.frontRight.harvestedEnergy +
           damperOutputs.rearLeft.harvestedEnergy +
           damperOutputs.rearRight.harvestedEnergy;
  }

  /**
   * Calculate combined energy efficiency of the integrated system
   */
  private calculateCombinedEfficiency(
    fuzzyOutputs: SystemOutputs,
    damperOutputs: any,
    totalDamperPower: number
  ): number {
    const totalGeneratedPower = fuzzyOutputs.regeneratedPower + totalDamperPower;
    
    if (totalGeneratedPower < 1) return 0;

    // Weight efficiency by power contribution
    const brakingWeight = fuzzyOutputs.regeneratedPower / totalGeneratedPower;
    const damperWeight = totalDamperPower / totalGeneratedPower;

    const avgDamperEfficiency = (
      damperOutputs.frontLeft.energyEfficiency +
      damperOutputs.frontRight.energyEfficiency +
      damperOutputs.rearLeft.energyEfficiency +
      damperOutputs.rearRight.energyEfficiency
    ) / 4;

    return (fuzzyOutputs.energyRecoveryEfficiency * brakingWeight) +
           (avgDamperEfficiency * damperWeight);
  }

  /**
   * Calculate system-wide energy balance
   */
  private calculateEnergyBalance(
    fuzzyOutputs: SystemOutputs,
    totalDamperPower: number,
    inputs: IntegratedSystemInputs
  ): {
    regenerativeBrakingPower: number;
    damperPower: number;
    totalGeneratedPower: number;
    powerConsumption: number;
    netEnergyFlow: number;
  } {
    const regenerativeBrakingPower = fuzzyOutputs.regeneratedPower;
    const damperPower = totalDamperPower;
    const totalGeneratedPower = regenerativeBrakingPower + damperPower;

    // Estimate power consumption based on vehicle operation
    const powerConsumption = this.estimatePowerConsumption(inputs);

    const netEnergyFlow = totalGeneratedPower - powerConsumption;

    return {
      regenerativeBrakingPower,
      damperPower,
      totalGeneratedPower,
      powerConsumption,
      netEnergyFlow
    };
  }

  /**
   * Estimate vehicle power consumption
   */
  private estimatePowerConsumption(inputs: IntegratedSystemInputs): number {
    const baseConsumption = 2000; // Base vehicle systems (W)
    
    // Speed-dependent consumption (aerodynamic drag)
    const speedConsumption = Math.pow(inputs.vehicleSpeed / 100, 2) * 5000;
    
    // Acceleration-dependent consumption
    const accelConsumption = Math.abs(inputs.longitudinalAcceleration) * 1000;
    
    // Auxiliary systems consumption
    const auxConsumption = 1000; // Lights, HVAC, etc.

    return baseConsumption + speedConsumption + accelConsumption + auxConsumption;
  }

  /**
   * Apply energy management strategies
   */
  private applyEnergyManagement(
    fuzzyOutputs: SystemOutputs,
    damperOutputs: any,
    totalDamperPower: number,
    inputs: IntegratedSystemInputs
  ): {
    fuzzyOutputs: SystemOutputs;
    damperOutputs: any;
    totalDamperPower: number;
  } {
    let managedFuzzyOutputs = { ...fuzzyOutputs };
    let managedDamperOutputs = { ...damperOutputs };
    let managedTotalDamperPower = totalDamperPower;

    // Apply battery charging threshold
    if (inputs.batterySOC >= this.config.energyManagement.batteryChargingThreshold) {
      const reductionFactor = 0.1; // Reduce to 10% when battery is full
      
      managedFuzzyOutputs.regeneratedPower *= reductionFactor;
      managedTotalDamperPower *= reductionFactor;
      
      // Reduce damper power generation
      Object.keys(managedDamperOutputs).forEach(key => {
        managedDamperOutputs[key].generatedPower *= reductionFactor;
      });
    }

    // Apply combined power limit
    const totalPower = managedFuzzyOutputs.regeneratedPower + managedTotalDamperPower;
    if (totalPower > this.config.energyManagement.maxCombinedPower) {
      const scaleFactor = this.config.energyManagement.maxCombinedPower / totalPower;
      
      if (this.config.energyManagement.prioritizeBrakingOverDamping) {
        // Prioritize regenerative braking, scale down dampers more
        const brakingScale = Math.min(1.0, scaleFactor * 1.2);
        const damperScale = Math.min(1.0, scaleFactor * 0.8);
        
        managedFuzzyOutputs.regeneratedPower *= brakingScale;
        managedTotalDamperPower *= damperScale;
        
        Object.keys(managedDamperOutputs).forEach(key => {
          managedDamperOutputs[key].generatedPower *= damperScale;
        });
      } else {
        // Equal scaling
        managedFuzzyOutputs.regeneratedPower *= scaleFactor;
        managedTotalDamperPower *= scaleFactor;
        
        Object.keys(managedDamperOutputs).forEach(key => {
          managedDamperOutputs[key].generatedPower *= scaleFactor;
        });
      }
    }

    // Apply thermal management
    if (this.config.energyManagement.thermalManagementEnabled) {
      const thermalOutputs = this.applyThermalManagement(
        managedFuzzyOutputs,
        managedDamperOutputs,
        inputs
      );
      managedFuzzyOutputs = thermalOutputs.fuzzyOutputs;
      managedDamperOutputs = thermalOutputs.damperOutputs;
      managedTotalDamperPower = this.calculateTotalDamperPower(managedDamperOutputs);
    }

    return {
      fuzzyOutputs: managedFuzzyOutputs,
      damperOutputs: managedDamperOutputs,
      totalDamperPower: managedTotalDamperPower
    };
  }

  /**
   * Apply thermal management to prevent overheating
   */
  private applyThermalManagement(
    fuzzyOutputs: SystemOutputs,
    damperOutputs: any,
    inputs: IntegratedSystemInputs
  ): {
    fuzzyOutputs: SystemOutputs;
    damperOutputs: any;
  } {
    let managedFuzzyOutputs = { ...fuzzyOutputs };
    let managedDamperOutputs = { ...damperOutputs };

    // Check motor temperatures
    const avgMotorTemp = (inputs.motorTemperatures.frontLeft + inputs.motorTemperatures.frontRight) / 2;
    if (avgMotorTemp > 120) {
      const thermalFactor = Math.max(0.3, 1 - (avgMotorTemp - 120) / 50);
      managedFuzzyOutputs.regeneratedPower *= thermalFactor;
    }

    // Check damper temperatures and apply thermal derating
    Object.keys(managedDamperOutputs).forEach(key => {
      const damperTemp = managedDamperOutputs[key].systemTemperature;
      if (damperTemp > 100) {
        const thermalFactor = Math.max(0.2, 1 - (damperTemp - 100) / 30);
        managedDamperOutputs[key].generatedPower *= thermalFactor;
      }
    });

    return {
      fuzzyOutputs: managedFuzzyOutputs,
      damperOutputs: managedDamperOutputs
    };
  }

  /**
   * Validate integrated system inputs
   */
  private validateIntegratedInputs(inputs: IntegratedSystemInputs): void {
    // Validate base system inputs (handled by fuzzy control system)
    
    // Validate suspension inputs
    const suspensionKeys = ['frontLeft', 'frontRight', 'rearLeft', 'rearRight'];
    suspensionKeys.forEach(key => {
      const suspInput = inputs.suspensionInputs[key as keyof typeof inputs.suspensionInputs];
      if (!suspInput) {
        throw new Error(`Missing suspension input for ${key}`);
      }
    });
  }

  /**
   * Get comprehensive system diagnostics
   */
  public getSystemDiagnostics(): {
    fuzzyControlDiagnostics: any;
    damperDiagnostics: {
      frontLeft: any;
      frontRight: any;
      rearLeft: any;
      rearRight: any;
    };
    systemMetrics: {
      totalSystemEnergy: number;
      operationTime: number;
      averagePowerGeneration: number;
      systemEfficiency: number;
    };
    configuration: HydraulicDamperSystemConfig;
  } {
    const fuzzyDiagnostics = this.fuzzyControlSystem.getDiagnostics();
    
    const damperDiagnostics = {
      frontLeft: this.dampers.frontLeft.getDiagnostics(),
      frontRight: this.dampers.frontRight.getDiagnostics(),
      rearLeft: this.dampers.rearLeft.getDiagnostics(),
      rearRight: this.dampers.rearRight.getDiagnostics()
    };

    const totalDamperEnergy = Object.values(damperDiagnostics)
      .reduce((sum, diag) => sum + diag.totalEnergyHarvested, 0);

    const averagePowerGeneration = this.operationTime > 0 ? 
      this.totalSystemEnergy / this.operationTime : 0;

    return {
      fuzzyControlDiagnostics: fuzzyDiagnostics,
      damperDiagnostics,
      systemMetrics: {
        totalSystemEnergy: this.totalSystemEnergy,
        operationTime: this.operationTime,
        averagePowerGeneration,
        systemEfficiency: 0.85 // Placeholder - would be calculated from actual data
      },
      configuration: this.config
    };
  }

  /**
   * Update system configuration
   */
  public updateSystemConfiguration(newConfig: Partial<HydraulicDamperSystemConfig>): void {
    this.config = { ...this.config, ...newConfig };
    
    // Update individual damper configurations if provided
    if (newConfig.damperConfigs) {
      if (newConfig.damperConfigs.front) {
        this.dampers.frontLeft.updateConfiguration(newConfig.damperConfigs.front);
        this.dampers.frontRight.updateConfiguration(newConfig.damperConfigs.front);
      }
      if (newConfig.damperConfigs.rear) {
        this.dampers.rearLeft.updateConfiguration(newConfig.damperConfigs.rear);
        this.dampers.rearRight.updateConfiguration(newConfig.damperConfigs.rear);
      }
    }

    if (newConfig.damperConstraints) {
      if (newConfig.damperConstraints.front) {
        this.dampers.frontLeft.updateConstraints(newConfig.damperConstraints.front);
        this.dampers.frontRight.updateConstraints(newConfig.damperConstraints.front);
      }
      if (newConfig.damperConstraints.rear) {
        this.dampers.rearLeft.updateConstraints(newConfig.damperConstraints.rear);
        this.dampers.rearRight.updateConstraints(newConfig.damperConstraints.rear);
      }
    }
  }

  /**
   * Reset all system statistics
   */
  public resetSystemStatistics(): void {
    this.totalSystemEnergy = 0;
    this.operationTime = 0;
    
    Object.values(this.dampers).forEach(damper => {
      damper.resetStatistics();
    });
  }
}